name: Build & Release Wallora

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-release:
    runs-on: windows-latest
    permissions:
      contents: write
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
          components: rustfmt, clippy

      - name: Install dependencies
        run: npm install

      # --- Semantic version/orientation tagging ---
      - name: Generate new semantic tag (customized bump)
        id: taggen
        shell: bash
        run: |
          git fetch --tags
          latest_tag=$(git tag --list 'v*' | sort -V | tail -n 1)
          echo "Latest tag: $latest_tag"

          if [[ "$latest_tag" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major="${BASH_REMATCH[1]}"
            minor="${BASH_REMATCH[2]}"
            patch="${BASH_REMATCH[3]}"
          else
            major=1
            minor=0
            patch=0
          fi

          # Get commit messages from last tag
          if [[ -z "$latest_tag" ]]; then
            commits=$(git log --pretty=format:%s)
          else
            commits=$(git log "$latest_tag"..HEAD --pretty=format:%s)
          fi

          bump="patch"

          if echo "$commits" | grep -q "BREAKING CHANGE"; then
            bump="major"
          elif echo "$commits" | grep -q "^feat"; then
            bump="minor"
          elif echo "$commits" | grep -q "^fix"; then
            bump="patch"
          fi

          case $bump in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          new_tag="v$major.$minor.$patch"
          echo "New tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

          # Skip tag if already present (safety for workflow restarts)
          if git tag | grep -q "$new_tag"; then
            echo "Tag $new_tag already exists, skipping tag creation."
          else
            git config user.name "github-actions"
            git config user.email "github-actions@github.com"
            git tag "$new_tag"
            git push origin "$new_tag"
          fi

      # --- Build the app (includes .exe, .msi, .msix) ---
      - name: Build Wallora (Tauri)
        run: npm run tauri build

      - name: Get Artifacts Paths
        id: artifacts
        shell: bash
        run: |
          msi=$(ls src-tauri/target/release/bundle/msi/*.msi | head -n 1 || true)
          exe=$(ls src-tauri/target/release/bundle/nsis/*.exe | head -n 1 || true)
          msix=$(ls src-tauri/target/release/bundle/msix/*.msix | head -n 1 || true)
          echo "msi=$msi" >> $GITHUB_OUTPUT
          echo "exe=$exe" >> $GITHUB_OUTPUT
          echo "msix=$msix" >> $GITHUB_OUTPUT

      - name: Upload MSI Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Wallora-MSI
          path: ${{ steps.artifacts.outputs.msi }}

      - name: Upload EXE Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Wallora-EXE
          path: ${{ steps.artifacts.outputs.exe }}

      - name: Upload MSIX Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Wallora-MSIX
          path: ${{ steps.artifacts.outputs.msix }}

      # --- Create Draft GitHub Release with Artifacts ---
      - name: Create GitHub Release
        if: steps.taggen.outputs.new_tag != ''
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.taggen.outputs.new_tag }}
          name: Wallora ${{ steps.taggen.outputs.new_tag }}
          body: |
            Automated pre-release.
            See [CHANGELOG](CHANGELOG.md) for details.
          prerelease: true
          files: |
            ${{ steps.artifacts.outputs.msi }}
            ${{ steps.artifacts.outputs.exe }}
            ${{ steps.artifacts.outputs.msix }}
